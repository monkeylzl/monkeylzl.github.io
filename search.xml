<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>百度地图面试</title>
    <url>/2017/05/16/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>这次「百度地图的 Android 开发」面试问的非常基础，基本是涵盖了所有的Java的基础和Android的基础，数据结构和算法没有涉及到，非常的详细，很小的知识点都会覆盖，和自己最初准备的还是有些差距同时也让我认识到了基础的重要性吧，还是有些漏洞的。</p>
<span id="more"></span>

<p>面试的主要问题：</p>
<ol>
<li>注释有哪些？</li>
<li>各种访问修饰符，哪些可以修饰类，哪些可以修饰方法，那些可以修饰变量，以及修饰的范围是什么？</li>
<li>try-catch 的用法，里面可以使用 return 语句吗？</li>
<li>异常有哪些？</li>
<li>线程的状态有哪些？</li>
<li>抽象类与接口的区别？</li>
<li>Java 中序列化，序列化的作用？</li>
<li>Android 的四大组件？</li>
<li>activity 的周期和启动模式</li>
<li>activity 中如果出现弹窗的活动周期？</li>
<li>Broadcast 有哪些类型？ Android 5.0, 6.0，7.0 中对Broadcast做了哪些修改？</li>
<li>Server 的周期与启动？</li>
<li>Android 的优化做过没有？</li>
<li>内存的泄露？</li>
<li>http 和 https 有什么区别？</li>
<li>设计模式有哪些？</li>
<li>ListView 的优化，ViewHolder 的使用？</li>
<li>bitmap 的缩略图？我只是抓住采样的计算，当时是不是考官想要知道 bitmap 的加载和缓存机制呢？</li>
<li>用过的 IDE 有哪些？ Gradle 的用法？</li>
<li>有没有什么 C 语言的编写能力？</li>
<li>为什么学的是通信，现在选择的是 Android？</li>
<li>爱好是什么？</li>
<li>介绍实验室的通信的项目？</li>
</ol>
<p>总结：</p>
<p>①全程感觉发挥的并不是很好，现在想想很多地方还可以在完善一些，可能跟自己准备的出入很大，以及一开始的基础知识回答的并不是很好影响了自己，暴露自己的问题就是基础的知识的不扎实。</p>
<p>②当考官透漏出一些信息时，虽然不是很明显，但你要能够抓住这个东西，比如这次的实习的时间上问题。认识到问题的关键就应该快速的给出自己的合理的想法，而不要让已有的想法框住自己，既然自己很想抓住这次机会，那就要能够用语言表达出来，而不是仅仅停留在想的基础上。</p>
<p>③突然意识到了自己的一个更大的问题，想与表达出来，平时大部分都是和自己待在一起，自己在思考，在纸上练习，很少将自己想的东西表达出来，导致面试的时候可能想到了，但是考官没有问到，也就没有说出来。</p>
<p>④还有一点就是参加面试的前一天最好不在看新的的知识，而是踏踏实实的把自己看过的知识好好的巩固一下。因为看新的知识，可能很幸运恰好被问到，但是由于刚刚看过们很可能由于轻微的紧张根本想不到，就像这次的  bitmap 当时就没有想到加载和缓存这块，所以功夫要下在平时，抛弃一些安全感，并将面试看成一次自我的检验，过后总结补充。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试记录</tag>
      </tags>
  </entry>
  <entry>
    <title>美团面试</title>
    <url>/2017/05/06/%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>今天参加了美团的暑期实习的 Android 的开发岗，在此进行一下总结：</p>
<span id="more"></span>

<ol>
<li>简历，一定要体现真诚，不会的不知道的一定不要写，因为面试的一面基本上就是按照简历来问。</li>
<li>面试的过程中，最大限度的表达出自己所知道的东西，即使是对考官所提问题不是很了解，但稍微相关的可以自己提出来，引导主考官向自己熟悉的地方继续问，有效地沟通。</li>
<li>面试的全程不要担心自己不会，不会就直接说不是很了解，但此时一定要体现出自己好学，突出自己学习能力。</li>
<li>学会适当的包装自己的项目，也就是简历上写的高大上一些，尤其是通信项目，对方不是很懂，但当他问时，需要能够通俗的用类比的方法进行讲解。对于相关的项目，考官比你知道的要多，就不要过分的把自己不知道的也写上，尽量把项目所用的知识点能够清晰的罗列出来，细节的展现。</li>
<li>算法是基本功，有些知识可能是知道，但题目可能是不一样的，如何将这个知识点应用到所出的题中，需要通过刷题来进行巩固，其次不要忽略时间复杂度，空间复杂度的计算，面试官一般都会问你的这个算法的时间复杂度和空间复杂度是多少，可能还会问怎么进行优化。</li>
<li>面试过程是将自己知道的知识点讲解出来，在讲的的过程很可能你会发现当自己对于一个知识点不是很理解时，是很难讲清楚的，所以要学会讲出来或者写出来。</li>
<li>具体的问题有：Android四大组件，HTTP、TCP/IP，垃圾回收GC，归并算法变型</li>
</ol>
<p>一些常见的问题：</p>
<p>1.你的缺点是什么？</p>
<p>这个是考察自己的自己的认知，只要体现自己的真实想法就可以，从最近自己的感悟出发，如自己的注意力或者专注度不够高，并举自己例子进行说明，如现在是信息爆炸的时代，但真正对自己有用的并不是很多，一些明星八卦等吸引了我们太多的注意力，但这对于我们自身的成长并没有起到实质的促进作用，并由此引出自己的缺点是对自己的注意力的把控与管理不是很好，正在努力的改善提高自己掌控自己的注意力，以集中更多的精力投入到自我的成长中。</p>
<p>2.你的爱好是什么？</p>
<p>两个方面考虑：</p>
<p>一是与求职的职位相关的爱好：</p>
<p>比如写博客分享自己对某个知识点的理解，详解其中自己写博客的感悟：</p>
<p>①可以巩固自己对这个知识点的把握，只有自己真正写出来其中细节、逻辑关系、这个知识点的全面性等才能充分的体现出来；</p>
<p>②可以见证自己的成长，增强自己的信心，充实自己；</p>
<p>③可以分享自己的观点，如果能够帮助遇到相同的问题的人，这个对自己来说应该说是一种鼓励，有一种巨大的成就感。</p>
<p>二是与求职职位无关的爱好;</p>
<p>比如自己特别喜欢运动，打篮球、跑步、健身、骑行等，这里的每一个点尽量都可以例举很多自己真正的自我体验，最好能有自己的真实感悟，比如喜好健身，首先有一个目标，我要锻炼那块肌肉，然后针对这个目标我做了哪些有效的动作，影响效果的关键是在做动作的过程中自己的注意力是否充分的集中到那块要发力的肌肉，最后要做到的就是持之以恒坚持下去，并通过这个爱好讲述从中获得很大的感悟，体验到其实完成一项任务的过程与之类似。</p>
<p>3.你还有什么问题？</p>
<p>两个方面考虑：</p>
<p>一是与技术无关的问题：</p>
<p>①针对于应聘职位，在您看来，贵公司对于一个应届实习生有哪些要求，对于技能的掌握应该达到一个怎样的程度？</p>
<p>可以知道面试官这次面试主要考察的是哪几方面，同时自己可以对应的查看自己的这几方面，那个表现的不是足够好，可以直接说出自己对这次面试的感觉，哪些做的不够好，关键是突出自己下来会继续学习，并希望能够尽快达到面试官的要求！</p>
<p>②如果我能够有幸加入您的团队，我会做那些具体的工作？</p>
<p>看是否自己真正喜欢，是否对于自己成长有很大帮助，毕竟是一个双向选择的机会。</p>
<p>③您面试过这么多人，对于一些优秀的面试者他们都具有那些特点？</p>
<p>这其实一方面体现自己向着优秀前进，一方面可以看出面试官自己心中对于面试者的形象，而且这应该是发自于面试官内心的想法。</p>
<p>比如这次面试官说，「对技术的热爱」，这就可以充分体现出面试官自己就是一个极爱技术的人，其实这里自己可以直接顺便带一句，「虽然这次面试表现自己对技术掌握的并不是很好，但我也是一个热爱技术的人，下来自己会继续努力，掌握更多技术，提高自己的能力。」</p>
<p>④通过这次面试，我感觉自己的哪几方面比较薄弱，自己先进行归纳，然后问考官，以您多年的经验来看，我还有哪些具体的方面需要接下来好好努力的？下来会继续努力。毕竟经过一次面试，最主要的是要获得经验，并弥补自己的不足。</p>
<p>二是与技术相关的问题：</p>
<p>⑤准备一个简单的中级的技术问题，有风险，因为一旦所问的问题考官不知道这就尴尬了，所以请谨慎。由于这方面提问前提是你对于一个技术有较高层次的认识，才能提出有一定水平的问题，从而体现出自己对于技术的钻研和热爱。</p>
<p>4.你为什么喜欢 Android ？</p>
<p>这个问题，我之前有考虑过，主要是通过对比突出我的想法，在实验室做的都是一些关于无线通信方面的项目，着这个过程中有哪些弊端，而 学习 Android 可以得到不同的体验！</p>
<p>比如有很多文献是鱼龙混杂的，有时甚至根本不能找到一个问题的很好的解决办法，相应的在学 Android 的过程中，当自己遇到一个问题，不管是通过博客，还是 GitHub,这个问题基本上都会有较好的解决，实在不行还可以直接找源码看，这个是最根本的方法，而科研是没有源码这个东西的。</p>
<p>其次无线通信的理论研究，大部分是通过仿真来进行验证的，并不像 Android 可以做出最终的成品并进行体验，不断地完善它直到自己满意为止，这个是一种巨大的成就感和自我的鼓励！</p>
<p>5.当你遇到一个问题是如何解决的？</p>
<p>第一个层次：工欲善其事必先利其器，初期我解决问题的几大法宝：Google，GitHub，博客，StackOverFlow 以及一些官方说明文档，当然一切问题最终都可以通过阅读远吗进行解决，目前自己也在不断地尝试阅读源码解决问题，不过自己还处于初级阶段，阅读的源码并不是很多。</p>
<p>第二个层次：和别人探讨，在自己经过努力查找之后，可能依然没有弄明白，这时我会找最方便的对这方面有所了解的人，直接进行探讨。</p>
<p>第三个层次：这个也是我是一直渴望的，希望能有一个经验上技术上的大牛，进行指点，比如向您一样的人，因为他们对于技术的理解要远高于我，可能他们的一句话，就能让我恍然大悟。当然，这些大牛也很忙，这就需要我前面的几个层次的准备，这个问题经过努力仍未解决。我认为我也希望能够帮助这些大牛做些力所能及的事，因为我感觉一味的索取总是让人感觉不舒服，所以对于帮助过我的人，我也会尽自己所能去帮助他。所以希望能够多接触这些大牛，崇拜之余不断的提升自我。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Android</title>
    <url>/2017/03/08/Android/</url>
    <content><![CDATA[<p>Android环境的搭建主要有三个部分：JDK，IDE，SDK</p>
<span id="more"></span>
<h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><p>由于Android的主题部分采用的是Java语言，所以首先进行Java环境的配置</p>
<ol>
<li>下载JDK，官网下载地址<a href="">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a>，选择相应的JDK。<br><img src="https://raw.githubusercontent.com/monkeylzl/MarkdownPhotos/master/AndroidEnvironmentBuilding/JDK.png"><br>安装过程中可以自定义路径，这里以”D:\Java\jdk1.8.0_101”和”D:\Java\jre1.8.0_101”为例，注意安装路径中不要出现中文或者是空格，等待安装完。<br>JDK=Java Development Kit，Java开发工具集，主要包括JRE和编译器组件。是进行Java开发的必要环境。所以安装JDK就包括JRE的安装。JDK是JRE的完全超集。<br>JRE=Java Runtime Environment，Java运行时环境，主要提供运行Java Class的环境。JDK中本身包含JRE。如果只想运行Java程序，而不需要进行编译（非开发环境，生产环境），可以安装JRE，不用安装JDK。<br>JVM=Java Virtue Machine，Java虚拟机。Java是一种半编译半解释程序，.java源程序经过编译后生成字节码文件.class文件。JVM虚拟机就是一个虚拟的计算机专门用来运行Java程序的虚拟计算机。JVM虚拟机会在安装JRE的时候自动安装</li>
<li>配置环境变量<br>我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量,配置JAVA_HOME，PATH，CLASSPATH。  </li>
</ol>
<p><strong>用户变量</strong>  </p>
<ul>
<li><p>变量名：JAVA_HOME，<br>变量值：D:\Java\jdk1.8.0_101（填写自己的安装路径）  </p>
</li>
<li><p>变量名：Path<br>变量值：D:\Java\jdk1.8.0_101\bin<br>注意：原来Path变量中有的变量值不要覆盖，直接将D:\MyEclipse\Java\jdk1.8.0_101\bin放在最前面，最后加分号进行隔离  </p>
</li>
</ul>
<p> <strong>系统变量</strong>  </p>
<ul>
<li>变量名：CLASSPATH<br>变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;<br>注意：最前面的点不要忘记，JAVA_HOME是java安装目录,但要加上2个%比如%JAVA_HOME%系统才能识别<br><img src="https://raw.githubusercontent.com/monkeylzl/MarkdownPhotos/master/AndroidEnvironmentBuilding/variable.png"> </li>
</ul>
<ol start="3">
<li>配置成功之后，运行cmd（win+R），测试java和javac命令，出现如图所示表示配置成功。<br><img src="https://raw.githubusercontent.com/monkeylzl/MarkdownPhotos/master/AndroidEnvironmentBuilding/cmdjava.png"><br><img src="https://raw.githubusercontent.com/monkeylzl/MarkdownPhotos/master/AndroidEnvironmentBuilding/cmdjavac.png"></li>
</ol>
<ul>
<li>可以运行java -version命令查看自己的JDK版本,确定java version版本与文件夹D:\Java\jdk1.8.0_101一致，位数与自己电脑的一致。<br><img src="https://raw.githubusercontent.com/monkeylzl/MarkdownPhotos/master/AndroidEnvironmentBuilding/JavaVersion.png"><h4 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h4></li>
</ul>
<p><strong>Android Studio的安装</strong></p>
<ul>
<li>下载<a href="https://developer.android.com/studio/index.html">Android Developer官网</a></li>
<li>安装时按照提示即可，安装过程中会提示SDK的安装路径，<strong>注意一定不要包含空格等特殊字符</strong></li>
<li>第一次打开会出现如下情况<br><img src="https://raw.githubusercontent.com/monkeylzl/MarkdownPhotos/master/AndroidEnvironmentBuilding/problem.png"><br>为了避免，可以在第一次运行AS时要在D:\Android\Android Studio\bin\idea.properties中添加<br>disable.android.first.run=true即可</li>
</ul>
<h4 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h4><ul>
<li>在安装Android Studio时刻会安装SDK，但是需要更多的Android版本时，需要打开SDK Manager下载，此时需要进行翻墙，可以进行如下设置，选择Tools-&gt;options,进行下图的设置，一定要勾选Force…<br><img src="https://raw.githubusercontent.com/monkeylzl/MarkdownPhotos/master/AndroidEnvironmentBuilding/Internet.png"><br>设置完之后，选择Packages-&gt;Reload，即可下载更新<br><img src="https://raw.githubusercontent.com/monkeylzl/MarkdownPhotos/master/AndroidEnvironmentBuilding/Reload.png"></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之继承</title>
    <url>/2017/03/09/Java%E4%B9%8B%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>继承是类与类的一种关系，是一种“is a”的关系。<br>继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新能力。</p>
<span id="more"></span>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ol>
<li>子类继承父类时，子类是不可以继承父类的构造函数，必须调用父类的构造函数<br>具有两种情况：<br>第一种：隐含super()形式，父类具有无参构造器或默认构造器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125; <span class="comment">//父类具有默认的构造器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">//可以省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">  public A()&#123;</span><br><span class="line">    System.out.print(&quot;父类无参构造器&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;  	 </span><br><span class="line">  public B()&#123;</span><br><span class="line">    super(); //可以省略</span><br><span class="line">    System.out.print(&quot;子类无参构造器&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 结果显示：父类无参构造器<br>　　　　　子类无参构造器<br>第二种：显示super()形式，父类具有有参构造器，super(参数)；一定要放在构造方法的首行上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    public A(String name)&#123;</span><br><span class="line">        System.out.print(&quot;父类有参构造器&quot;);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">    public B()&#123;</span><br><span class="line">        super(&quot;lzl&quot;); //不可省略，()中的内容可任意，只要符合String类型，必须在首行</span><br><span class="line">        System.out.print(&quot;子类无参构造器&quot;);</span><br><span class="line">  	&#125;</span><br><span class="line"> &#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        B b = new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果显示：父类有参构造器<br>　　　　　子类无参构造器<br>如果要实例化子类对象，会默认先调用父类构造，为父类之中的属性初始化，之后再调用子类构造，为子类之中的属性初始化，即：默认情况下，子类会找到父类之中的无参构造方法。<br>2. 继承只能是单继承，但存在多层继承</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class C extends A,B&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>是错的，但是可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class B extends A&#123;&#125;</span><br><span class="line">class C extends B&#123;&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>子类继承父类时，调用方法时优先选择子类中被重写的方法，若没有，就会调用父类中的方法<br>继承时，子类可以创建父类中没有的方法，也可以使用；<br>但使用过程中需要注意，在多态里子类创建了自己的方法后，通过向上转型进行动态绑定创建对象后，对象调用子类自己创建的方法会报错<br>Animal dog = new Dog();这句表现的是JAVA的多态，表示由一个父类的引用指向子类，因为是引用的是动物类型，而动物类没有getC()方法，所以编译器会认为，这个方法是不存在的。如果要通过编译必须这样写：Dog dog = new Dog();这就没有体现java中的多态，没有父类引用指向子类对象，只是继承。<br>好比是：我说要一个动物，你给我一只小狗，这是可以的，但是狗会啃骨头，并不等于其他动物都会啃骨头。所以你给我一个动物，然后告诉我它要啃骨头，然而这只动物未必是小狗，所以我告诉你编译错误了。  </li>
<li>在一个子类继承的时候，实际上会继承父类之中的所有操作（属性、方法），但是需要注意的是，对于所有的非私有（no private）操作属于显式继承（可以直接利用对象操作），而所有的私有操作属于隐式继承（间接完成）。通过利用对象操作调用父类private属性如下所示：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    private String str;</span><br><span class="line">    public void setStr(String str) &#123;</span><br><span class="line">        this.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getStr() &#123;</span><br><span class="line">        return this.str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        //System.out.println(str); // 错误: str定义为private，不可见</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        B b = new B();</span><br><span class="line">        b.setStr(&quot;hello&quot;);</span><br><span class="line">        System.out.println(b.getStr());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3>实现了代码的复用，减少代码冗余<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName(String name)&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName(String name)&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge(int age)&#123;</span><br><span class="line">        return this.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
若没有继承，这种代码的重复是不可避免的。</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
